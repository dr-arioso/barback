{
  "version_info": {
    "version": "1.3.0",
    "schema_version": "2025-12",
    "compiler_version": "2.0",
    "source_hash": "sha256:dff9b249e959ac37e00779cdba0247e51efd29581485c743ba2fc342f7a85530",
    "timestamp": "2025-12-07T07:53:55Z"
  },
  "entities": {
    "stashkit.core": {
      "id": "stashkit.core",
      "name": "StashKit",
      "type": "system",
      "description": "The primary framework for transforming messy real-world inputs into structured, domain-aware entities using resolvers and skills, backed by one or more StashDexes and persisted in user Stashes.\n",
      "traits": [
        "knowledge_engine",
        "resolver_host",
        "skill_orchestrator",
        "ontology_builder",
        "stash_host",
        "boosterpack_host"
      ],
      "fields": {
        "responsibilities": [
          "Coordinate resolvers and skills to interpret heterogeneous inputs.",
          "Build and manage StashDexes as lexical and ontological references.",
          "Normalize messy inputs into structured entities suitable for storage in Stashes.",
          "Manage registration of skills, resolvers, StashDexes, and BoosterPacks.",
          "Provide a stable, high-level API (e.g. fetch) for applications and BoosterPacks."
        ],
        "key_components": [
          "stashkit.resolvers",
          "stashkit.skills",
          "stashkit.stashdex",
          "stashkit.stash",
          "stashkit.boosterpacks"
        ]
      },
      "api": {
        "public_methods": [
          {
            "name": "fetch",
            "description": "Invoke a resolver → skill-chain → Dex pipeline to interpret a request. May optionally store the result in a Stash.\n",
            "params": [
              "request",
              "resolver_id",
              "stash",
              "options"
            ],
            "returns": "StructuredEntity | PartialEntity"
          },
          {
            "name": "register_skill",
            "description": "Register a Skill in the system-wide registry.",
            "params": [
              "skill"
            ],
            "returns": "None"
          },
          {
            "name": "register_resolver",
            "description": "Register a Resolver in the system-wide registry.",
            "params": [
              "resolver"
            ],
            "returns": "None"
          },
          {
            "name": "install_booster",
            "description": "Install a BoosterPack and register its components.",
            "params": [
              "pack_id"
            ],
            "returns": "None"
          },
          {
            "name": "get_dex",
            "description": "Retrieve a StashDex by identifier and optional version.",
            "params": [
              "dex_id",
              "version"
            ],
            "returns": "StashDex"
          },
          {
            "name": "create_stash",
            "description": "Create a new Stash with the given identifier and optional metadata.",
            "params": [
              "stash_id",
              "metadata"
            ],
            "returns": "Stash"
          }
        ],
        "internal_methods": [
          {
            "name": "_dispatch_resolver",
            "description": "Internal resolver selection and invocation logic."
          }
        ],
        "properties": [
          {
            "name": "registry",
            "description": "Registry of installed skills, resolvers, StashDexes, and BoosterPacks."
          }
        ],
        "events": [
          {
            "name": "on_resolver_missing",
            "description": "Fired when no resolver can interpret a request."
          }
        ]
      }
    },
    "stashkit.resolvers": {
      "id": "stashkit.resolvers",
      "name": "Resolver Subsystem",
      "type": "subsystem",
      "description": "Resolves user requests by orchestrating skills, consulting StashDexes, and assembling coherent entities suitable for persistence in Stashes.\n",
      "traits": [
        "orchestrates_skills",
        "domain_aware",
        "input_interpreter",
        "entity_builder"
      ],
      "fields": {
        "responsibilities": [
          "Gather raw or partial inputs from multiple signal sources.",
          "Invoke appropriate skills in a configured or dynamic sequence.",
          "Maintain partial entities and confidence models while merging proposals.",
          "Consult StashDexes for normalization, classification, and enrichment.",
          "Decide when resolution is sufficient using domain-specific termination rules.",
          "Produce structured domain entities ready to be stored in Stashes."
        ],
        "typical_fields": [
          "domain",
          "target_entity_type",
          "required_fields",
          "optional_fields",
          "skill_sequence",
          "termination_rules",
          "conflict_resolution_strategy",
          "supported_dexes"
        ]
      },
      "api": {
        "public_methods": [
          {
            "name": "resolve",
            "description": "Interpret a request by gathering signals, applying skills, consulting StashDexes, and building a structured entity.\n",
            "params": [
              "request",
              "stash",
              "options"
            ],
            "returns": "PartialEntity | StructuredEntity"
          }
        ],
        "internal_methods": [
          {
            "name": "_apply_skills",
            "description": "Construct the skill chain and apply it, updating the partial entity and confidence model."
          },
          {
            "name": "_score_candidates",
            "description": "Score and rank candidate entities based on confidence and domain rules."
          }
        ],
        "properties": [
          {
            "name": "domain",
            "description": "The domain or entity type handled by this resolver (e.g. product, bottle, herb, item)."
          },
          {
            "name": "target_entity_type",
            "description": "The concrete entity class or schema the resolver attempts to produce."
          },
          {
            "name": "required_fields",
            "description": "Field names that must be populated before the resolver considers an entity complete."
          },
          {
            "name": "optional_fields",
            "description": "Field names that may be populated when available but are not required for completion."
          },
          {
            "name": "skill_sequence",
            "description": "Ordered or conditional sequence of skills that this resolver may invoke."
          },
          {
            "name": "termination_rules",
            "description": "Rules that describe when resolution should stop."
          },
          {
            "name": "conflict_resolution_strategy",
            "description": "Strategy for reconciling conflicting proposals from skills or Dex lookups."
          },
          {
            "name": "supported_dexes",
            "description": "Identifiers of StashDexes this resolver knows how to consult."
          }
        ],
        "events": [
          {
            "name": "on_ambiguous_match",
            "description": "Fired when multiple entities or interpretations match with similar confidence."
          },
          {
            "name": "on_resolution_complete",
            "description": "Fired when the resolver produces a complete entity."
          },
          {
            "name": "on_partial_resolution",
            "description": "Fired when resolution stops with a partial entity."
          }
        ]
      }
    },
    "stashkit.skills": {
      "id": "stashkit.skills",
      "name": "Skill Subsystem",
      "type": "subsystem",
      "description": "Skills are composable units that operate on specific signal types (text, barcode, image, user input, partial entities, etc.) and propose field-level changes, often with confidence and provenance information, for resolvers to merge.\n",
      "traits": [
        "composable",
        "atomic",
        "reusable",
        "signal_processor"
      ],
      "fields": {
        "responsibilities": [
          "Extract information from input signals such as text, barcodes, or images.",
          "Transform or normalize values (e.g. canonicalizing product names or brands).",
          "Query external APIs or databases for enrichment.",
          "Interact with users to request missing or clarifying information.",
          "Propose updates to one or more fields on a partial entity."
        ],
        "typical_fields": [
          "skill_id",
          "signal_type",
          "produces_fields",
          "domain_specific",
          "requires_context"
        ]
      },
      "api": {
        "public_methods": [
          {
            "name": "apply",
            "description": "Apply the skill to the given input (and optional context), returning proposed field updates with optional confidence and provenance.\n",
            "params": [
              "input",
              "context"
            ],
            "returns": "ProposedChanges"
          }
        ],
        "internal_methods": [
          {
            "name": "_validate",
            "description": "Internal check for input structure and type prior to application."
          }
        ],
        "properties": [
          {
            "name": "skill_id",
            "description": "Unique identifier used for registration and selection by resolvers."
          },
          {
            "name": "signal_type",
            "description": "Signal type accepted by this skill (e.g. text, barcode, image, user_input, partial_entity)."
          },
          {
            "name": "produces_fields",
            "description": "Field names that this skill may propose or update on the partial entity."
          },
          {
            "name": "domain_specific",
            "description": "Whether the skill is tightly bound to a particular domain or generally reusable."
          },
          {
            "name": "requires_context",
            "description": "Whether the skill requires contextual information (e.g. Dex handle, configuration, or stash)."
          }
        ],
        "events": []
      }
    },
    "stashkit.stash": {
      "id": "stashkit.stash",
      "name": "Stash",
      "type": "subsystem",
      "description": "Persistent user collection of resolved entities. Each entity references a StashDex via a short key in the stash-level dex_table. The Dex itself may evolve over time without silently mutating stored entities.\n",
      "traits": [
        "persistent_storage",
        "user_collection",
        "dex_agnostic"
      ],
      "fields": {
        "responsibilities": [
          "Persist resolved entities so they can be retrieved without re-running full resolution.",
          "Maintain a dex_table mapping short keys (e.g. D1) to fully-qualified Dex identifiers.",
          "Allow entities from multiple domains and Dexes to coexist in one collection.",
          "Support optional re-resolution or re-enrichment when Dexes or resolvers change."
        ],
        "typical_fields": [
          "stash_id",
          "metadata",
          "dex_table",
          "entities"
        ],
        "dex_table_structure": {
          "example": {
            "D1": "BoozeDex.2025.04",
            "D2": "HerbDex.2026.01"
          }
        }
      },
      "api": {
        "public_methods": [
          {
            "name": "add",
            "description": "Add a resolved entity to the stash, associated with a Dex reference key.",
            "params": [
              "entity",
              "dex_ref_key"
            ],
            "returns": "EntityId"
          },
          {
            "name": "get",
            "description": "Retrieve a stored entity by identifier.",
            "params": [
              "entity_id"
            ],
            "returns": "StoredEntity"
          },
          {
            "name": "list",
            "description": "List entities matching basic criteria such as domain, tags, or Dex reference key.",
            "params": [
              "criteria"
            ],
            "returns": "List[StoredEntity]"
          },
          {
            "name": "update",
            "description": "Update fields on a stored entity, preserving historical metadata as needed.",
            "params": [
              "entity_id",
              "changes"
            ],
            "returns": "StoredEntity"
          },
          {
            "name": "re_resolve",
            "description": "Optionally re-run a resolver for a stored entity using current Dex and skill configuration, producing an updated entity while preserving or recording the original snapshot as desired.\n",
            "params": [
              "entity_id",
              "options"
            ],
            "returns": "StoredEntity | ResolutionDiff"
          }
        ],
        "internal_methods": [
          {
            "name": "_ensure_dex_ref",
            "description": "Ensure that a Dex identifier/version is present in dex_table and return its key."
          }
        ],
        "properties": [
          {
            "name": "stash_id",
            "description": "Identifier for this stash instance."
          },
          {
            "name": "metadata",
            "description": "Optional metadata about the stash (e.g. owner, creation time, app context)."
          },
          {
            "name": "dex_table",
            "description": "Mapping of short Dex keys (e.g. D1) to fully-qualified Dex identifiers."
          },
          {
            "name": "entities",
            "description": "Collection of stored entities in this stash."
          }
        ],
        "events": []
      }
    },
    "stashkit.boosterpacks": {
      "id": "stashkit.boosterpacks",
      "name": "BoosterPacks",
      "type": "concept",
      "description": "Optional extension bundles that add domain-specific StashDexes, entity schemas, resolvers, skills, and helper utilities. BoosterPacks allow StashKit to be extended to new domains without modifying the core framework.\n",
      "traits": [
        "optional",
        "domain_bundle",
        "package_extension",
        "shareable"
      ],
      "fields": {
        "responsibilities": [
          "Package domain-specific Dexes, entities, resolvers, skills, and utilities.",
          "Provide installable extensions that register themselves with StashKit Core.",
          "Support sharing and reuse of domain knowledge and resolution logic."
        ],
        "possible_contents": [
          "StashDexes",
          "Entity schemas",
          "Domain-specific resolvers",
          "General-purpose or domain-specific skills",
          "Utility modules and configuration defaults"
        ]
      },
      "api": {
        "public_methods": [
          {
            "name": "install",
            "description": "Install a BoosterPack by identifier and register its components.",
            "params": [
              "pack_id"
            ],
            "returns": "None"
          },
          {
            "name": "list",
            "description": "List installed BoosterPacks and their key components.",
            "params": [],
            "returns": "List[BoosterPackMetadata]"
          },
          {
            "name": "get",
            "description": "Retrieve metadata about a specific BoosterPack.",
            "params": [
              "pack_id"
            ],
            "returns": "BoosterPackMetadata"
          }
        ],
        "internal_methods": [],
        "properties": [
          {
            "name": "packs",
            "description": "Installed BoosterPacks and their metadata."
          }
        ],
        "events": []
      }
    },
    "stashkit.stashdex": {
      "id": "stashkit.stashdex",
      "name": "StashDex",
      "type": "concept",
      "description": "A lexicon, ontology, and inference engine for a domain. StashDex provides canonical entities, alias resolution, classification axes, and trait inference. It is not the end-user storage layer; that role is handled by Stash.\n",
      "traits": [
        "ontology",
        "lexical_reference",
        "semantic_model",
        "inference_host"
      ],
      "fields": {
        "responsibilities": [
          "Store canonical, domain-specific entities and traits.",
          "Handle aliases and synonyms for user-facing labels.",
          "Provide multi-axis classification (e.g. legal, functional, production-based).",
          "Infer additional traits from partial information and known rules.",
          "Evolve schema and knowledge without breaking previously stored stash entities."
        ],
        "typical_fields": [
          "version",
          "traits",
          "alias_maps",
          "rules",
          "classification_axes"
        ]
      },
      "api": {
        "public_methods": [
          {
            "name": "get",
            "description": "Retrieve a canonical entity from the Dex by identifier.",
            "params": [
              "entity_id"
            ],
            "returns": "StashDict"
          },
          {
            "name": "query",
            "description": "Search the Dex using semantic criteria such as traits, categories, or aliases.",
            "params": [
              "criteria"
            ],
            "returns": "List[StashDict]"
          },
          {
            "name": "update",
            "description": "Insert or update a canonical entity in the Dex.",
            "params": [
              "entity"
            ],
            "returns": "StashDict"
          },
          {
            "name": "resolve_alias",
            "description": "Resolve a name or alias into a canonical entity or label.",
            "params": [
              "name_or_alias"
            ],
            "returns": "AliasResolutionResult"
          },
          {
            "name": "infer",
            "description": "Infer additional traits or classifications for a partial entity.",
            "params": [
              "entity_fragment"
            ],
            "returns": "InferredTraits"
          }
        ],
        "internal_methods": [],
        "properties": [
          {
            "name": "version",
            "description": "Schema/version identifier for the Dex (e.g. BoozeDex.2025.04)."
          },
          {
            "name": "traits",
            "description": "Domain traits and classification rules represented by this Dex."
          },
          {
            "name": "alias_maps",
            "description": "Mappings from aliases and synonyms to canonical entities or labels."
          },
          {
            "name": "classification_axes",
            "description": "Classification dimensions such as bartender_style, legal_category, production_method, use_case."
          }
        ],
        "events": [
          {
            "name": "on_trait_propagation",
            "description": "Fired when traits propagate through hierarchies or classification axes."
          }
        ]
      }
    }
  },
  "relationships": [
    {
      "from": "stashkit.core",
      "to": "stashkit.resolvers",
      "type": "uses"
    },
    {
      "from": "stashkit.core",
      "to": "stashkit.skills",
      "type": "uses"
    },
    {
      "from": "stashkit.core",
      "to": "stashkit.stashdex",
      "type": "builds"
    },
    {
      "from": "stashkit.core",
      "to": "stashkit.stash",
      "type": "uses"
    },
    {
      "from": "stashkit.core",
      "to": "stashkit.boosterpacks",
      "type": "manages"
    },
    {
      "from": "stashkit.resolvers",
      "to": "stashkit.skills",
      "type": "orchestrates"
    },
    {
      "from": "stashkit.resolvers",
      "to": "stashkit.stashdex",
      "type": "consults"
    },
    {
      "from": "stashkit.resolvers",
      "to": "stashkit.stash",
      "type": "may_update"
    },
    {
      "from": "stashkit.skills",
      "to": "stashkit.stashdex",
      "type": "enriches"
    },
    {
      "from": "stashkit.stash",
      "to": "stashkit.stashdex",
      "type": "references"
    },
    {
      "from": "stashkit.boosterpacks",
      "to": "stashkit.stashdex",
      "type": "may_include"
    },
    {
      "from": "stashkit.boosterpacks",
      "to": "stashkit.resolvers",
      "type": "may_include"
    },
    {
      "from": "stashkit.boosterpacks",
      "to": "stashkit.skills",
      "type": "may_include"
    }
  ],
  "rules": [
    {
      "id": "propagate_core_traits",
      "rule_type": "trait_propagation",
      "applies_to": "system",
      "description": "Propagate selected traits from core systems to subsystems.",
      "logic": [
        {
          "when_system_id": "stashkit.core",
          "propagate_traits": {
            "traits": [
              "knowledge_engine"
            ],
            "to": [
              "stashkit.resolvers",
              "stashkit.skills",
              "stashkit.stashdex"
            ]
          }
        }
      ]
    },
    {
      "id": "resolver_supported_dex_consistency",
      "rule_type": "consistency",
      "applies_to": "subsystem",
      "description": "Ensure that stash entities using a resolver reference Dexes supported by that resolver.\n",
      "logic": [
        {
          "condition": "resolver.supported_dexes is not empty",
          "require": "stash.entities[*].dex_ref_key resolves via stash.dex_table to a Dex whose id is in resolver.supported_dexes\n"
        }
      ]
    },
    {
      "id": "stash_dex_table_references",
      "rule_type": "structural",
      "applies_to": "subsystem",
      "description": "Ensure that stash entities refer to Dexes through the stash dex_table using short keys.\n",
      "logic": [
        {
          "condition": "entity in stash.entities",
          "require": "entity.dex_ref_key in stash.dex_table"
        }
      ]
    }
  ]
}