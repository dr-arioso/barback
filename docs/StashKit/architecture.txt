ðŸ§± So what does StashKit need architecturally?

A clean separation:

StashKit (framework)
â”‚
â”œâ”€â”€ Model layer         (Item, Product, Bottle, etc.)
â”œâ”€â”€ Resolver layer      (ItemResolver, ProductResolver, StashSkills)
â””â”€â”€ Knowledge layer     (this is Option D)
     â”œâ”€â”€ Data Stores    (FilesystemStore, SQLiteStore, APIStoreâ€¦)
     â””â”€â”€ Ontologies     (hierarchical categories, controlled vocabularies)


So file structure would be something like:
StashKit
 â”œâ”€â”€ models/
 â”œâ”€â”€ stash/
 â”œâ”€â”€ resolvers/
 â”‚    â”œâ”€â”€ base.py (pipeline)
 â”‚    â”œâ”€â”€ manual.py
 â”‚    â””â”€â”€ skills/
 â”‚         â”œâ”€â”€ AIVisionSkill
 â”‚         â”œâ”€â”€ UPCSkill
 â”‚         â”œâ”€â”€ PublicDBSkill
 â”‚         â”œâ”€â”€ BrandSkill
 â”‚         â”œâ”€â”€ CategorySkill
 â”‚         â””â”€â”€ VolumeSkill
 â”œâ”€â”€ sources/
 â”‚    â”œâ”€â”€ stash_source.py   â† StashSource interface
 â”‚    â”œâ”€â”€ data_store.py     â† DataStore interface + fs/sql implementations
 â”‚    â””â”€â”€ ontology.py       â† Ontology engine
 â””â”€â”€ utils/
      â””â”€â”€ normalization.py


This is perfect because StashKit is:

- Domain-agnostic
- Capable of ingestion
- Capable of normalization
- But not opinionated

So StashKit should:
- NOT hardcode â€œspirits knowledgeâ€
- NOT assume â€œUPC existsâ€
- NOT enforce â€œbrand tablesâ€
- NOT assume â€œcategories are flatâ€
- NOT embed Barback-specific logic

But it should support those things when the calling application wants them.

And Barback becomes:
- One opinionated application built on StashKit
- Using StashKit knowledge primitives to compose its own brand/category ontology
- Without polluting StashKit itself


ðŸ›ï¸ Letâ€™s outline three pillars of StashKit architecture (using Barback as an example of the separation between library and caller)

Pillar 1 â€” Pluggable DataStores

Every app should be allowed to configure where it loads/saves metadata:

StashKitDataStore (abstract)
 â”œâ”€â”€ FilesystemStore (JSON/CSV/YAML)
 â”œâ”€â”€ SQLiteStore
 â”œâ”€â”€ LocalMemoryStore
 â”œâ”€â”€ RESTAPIStore
 â””â”€â”€ FirestoreStore / S3Store (future)


You specify one or more DataStores:

data_store = FilesystemStore("./metadata_cache")
resolver = BottleResolver(data_store=data_store)


Which gives you:
- Local cache of scanned bottles
- Local cache of user-added brands
- Local cache of UPC lookups
- Local cache of category mappings
And you never ship huge databases â€” you cache only what you use.

Failover:
UPC lookup skill tries:
- local store
- secondary local store (e.g., an offline fork)
- online public DB #1
- online public DB #2
- fallback to manual entry



Pillar 2 â€” Controlled Vocabularies / Ontologies

This is where your category/brand hierarchy belongs.

It should not be Barback-only.
Collectors, hobbyists, archivists will love it.

The right form is a lightweight ontology:

A simple model:

class OntologyNode(BaseModel):
    name: str
    parents: List[str] = []
    children: List[str] = []
    aliases: List[str] = []


And a manager:

class Ontology:
    def add_category(...)
    def ancestors(...)
    def descendants(...)
    def is_subcategory(...)

Examples from Barback:

Triple Sec
â†’ Orange Liqueur
â†’ Liqueur
â†’ Spirit
â†’ Alcoholic Product
â†’ Product (unless discussing generalized Triple Sec, then is an Item)
â†’ Item

Curacao
â†’ Orange Liqueur
â†’ (similar ancestor path)

Both are mixers. Cointreau L'Unique is also considered an aperitif and digestif (both of which would be Alcoholic Products, but not in the same parent-child chain).

Because:

Cointreau is both a triple sec and orange liqueur

Pierre Ferrand Dry Curacao is curacao AND orange liqueur
DeKuyper Blue Curacao is an orange liqueur but not a true Curacao

Let StashKit store:

ontology.add("Curacao", parent="Orange Liqueur")
ontology.add("Orange Curacao", parent="Curacao")
ontology.add("Triple Sec", parent="Orange Liqueur")
ontology.add("Flavored Brandy", parent="Liqueur")
ontology.add("Blue Curacao", parent="Orange Liqueur")

And calling code might use:

resolver.normalize_category("curacao")


To get a list like:

["Curacao", "Orange Liqueur", "Liqueur", "Spirit"]


StashKit should not enforce or supply any of these trees.
But it can supply the framework for managing them.

And calling code can enforce constraints like:
- â€œFor Tiki drinks, prefer Orange Curacaoâ€
- â€œCuracao implies Orange Liqueurâ€
- â€œNever treat Blue Curacao as Curacaoâ€

Ontology and similar data would be retrieved by Resolver.Skills, using a specified StashSource (KnowledgeProvider)


Pillar 3 â€” KnowledgeProvider abstraction We will call StashSource

Resolvers should not load brand lists, categories, UPC ranges, etc.
They should ask the KnowledgeProvider.

class KnowledgeProvider:
    def lookup_brand(self, name: str) -> Optional[BrandRecord]
    def suggest_brand(self, text: str) -> Optional[str]
    def get_category(self, name: str) -> OntologyNode
    def save_product_metadata(self, product: Product)
    ...


StashSource can wrap:
- a DataStore
- an Ontology
- a brand list
- a cache

This is where:
- brand aliasing
- category lookup
- user-normalized names
- merging heuristics
belong.